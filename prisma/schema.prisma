generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["fullTextSearch"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id            String         @id @default(cuid())
  email         String         @unique
  password      String
  name          String?        @unique(sort: Asc) @db.VarChar(255)
  image         String?
  banner        String?
  color         Json?
  verified      Boolean        @default(false)
  followToId    String?
  createAt      DateTime       @default(now())
  comment       Comment[]
  commentVote   CommentVote[]
  manga         Manga[]
  memberOnTeam  MemberOnTeam?
  messages      Message[]
  notifySent    Notify[]       @relation("fromUser")
  notifications Notify[]       @relation("toUser")
  owner         Team?
  followTo      User?          @relation("followTo", fields: [followToId], references: [id])
  follows       User[]         @relation("followTo")
  badge         Badge[]        @relation("BadgeToUser")
  conversation  Conversation[] @relation("ConversationToUser")

  @@index([followToId])
  @@index([email], type: Hash)
  @@index([name], type: Hash)
}

model MemberOnTeam {
  userId String @unique
  teamId Int
  team   Team   @relation(fields: [teamId], references: [id])
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, teamId])
  @@index([teamId])
}

model Team {
  id        Int            @id @default(autoincrement())
  image     String?
  name      String         @unique
  ownerId   String         @unique
  chapter   Chapter[]
  member    MemberOnTeam[]
  owner     User           @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  createdAt DateTime       @default(now())

  @@index([ownerId])
}

model Badge {
  id          Int    @id @default(autoincrement())
  image       String
  name        String
  color       Json
  description String
  user        User[] @relation("BadgeToUser")
}

model Manga {
  id           Int           @id @default(autoincrement())
  name         String
  description  Json
  image        String
  facebookLink String?
  discordLink  String?
  creatorId    String
  isPublished  Boolean       @default(false)
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
  chapter      Chapter[]
  comment      Comment[]
  creator      User          @relation(fields: [creatorId], references: [id], onDelete: Cascade)
  view         View?
  author       MangaAuthor[] @relation("MangaToMangaAuthor")
  tags         Tag[]         @relation("MangaToTag")

  @@unique([name, creatorId])
  @@index([creatorId])
}

model MangaAuthor {
  id    Int     @id @default(autoincrement())
  name  String  @unique
  manga Manga[] @relation("MangaToMangaAuthor")

  @@index([name])
}

model Tag {
  id          Int     @id @default(autoincrement())
  name        String  @unique
  description String
  category    String
  manga       Manga[] @relation("MangaToTag")
}

model Chapter {
  id           Int          @id @default(autoincrement())
  chapterIndex Int          @default(1)
  name         String?
  images       String[]
  volume       Int
  mangaId      Int
  teamId       Int?
  isPublished  Boolean      @default(false)
  createdAt    DateTime     @default(now())
  updatedAt    DateTime     @updatedAt
  manga        Manga        @relation(fields: [mangaId], references: [id])
  team         Team?        @relation(fields: [teamId], references: [id])
  comment      Comment[]
  dailyView    DailyView[]
  weeklyView   WeeklyView[]

  @@index([mangaId])
  @@index([teamId])
}

model Comment {
  id        Int           @id @default(autoincrement())
  content   Json
  oEmbed    Json?
  authorId  String
  mangaId   Int
  chapterId Int?
  replyToId Int?
  createdAt DateTime      @default(now())
  author    User          @relation(fields: [authorId], references: [id], onDelete: Cascade)
  chapter   Chapter?      @relation(fields: [chapterId], references: [id])
  manga     Manga         @relation(fields: [mangaId], references: [id])
  replyTo   Comment?      @relation("ReplyTo", fields: [replyToId], references: [id], onDelete: Cascade)
  replies   Comment[]     @relation("ReplyTo")
  votes     CommentVote[]

  @@index([authorId])
  @@index([chapterId])
  @@index([mangaId])
  @@index([replyToId])
}

model CommentVote {
  userId    String
  commentId Int
  type      VoteType
  comment   Comment  @relation(fields: [commentId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([userId, commentId])
  @@index([userId, commentId])
  @@index([commentId])
}

model View {
  mangaId    Int          @id
  totalView  Int
  dailyView  DailyView[]
  manga      Manga        @relation(fields: [mangaId], references: [id])
  weeklyView WeeklyView[]

  @@index([mangaId])
}

model DailyView {
  id        Int      @id @default(autoincrement())
  mangaId   Int
  chapterId Int
  createdAt DateTime @default(now())
  chapter   Chapter  @relation(fields: [chapterId], references: [id])
  view      View     @relation(fields: [mangaId], references: [mangaId], onDelete: Cascade)

  @@index([mangaId])
  @@index([chapterId])
}

model WeeklyView {
  id        Int      @id @default(autoincrement())
  mangaId   Int
  chapterId Int
  createdAt DateTime @default(now())
  chapter   Chapter  @relation(fields: [chapterId], references: [id])
  view      View     @relation(fields: [mangaId], references: [mangaId])

  @@index([mangaId])
  @@index([chapterId])
}

model Notify {
  id         Int        @id @default(autoincrement())
  type       NotifyType
  fromUserId String
  toUserId   String
  content    Json
  isRead     Boolean    @default(false)
  createdAt  DateTime   @default(now())
  fromUser   User       @relation("fromUser", fields: [fromUserId], references: [id], onDelete: Cascade)
  toUser     User       @relation("toUser", fields: [toUserId], references: [id], onDelete: Cascade)

  @@index([fromUserId])
  @@index([toUserId])
}

model Conversation {
  id        Int       @id @default(autoincrement())
  createdAt DateTime  @default(now())
  messages  Message[]
  users     User[]    @relation("ConversationToUser")
}

model Message {
  id             Int          @id @default(autoincrement())
  content        String
  conversationId Int
  senderId       String
  createdAt      DateTime     @default(now())
  conversation   Conversation @relation(fields: [conversationId], references: [id])
  sender         User         @relation(fields: [senderId], references: [id], onDelete: Cascade)

  @@index([conversationId])
  @@index([senderId])
}

enum VoteType {
  UP_VOTE
  DOWN_VOTE
}

enum NotifyType {
  LIKE
  COMMENT
  MENTION
  FOLLOW
  SYSTEM
}
